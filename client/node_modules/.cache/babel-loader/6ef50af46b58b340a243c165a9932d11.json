{"ast":null,"code":"import _slicedToArray from \"/home/phuong/shared/code/git/github/online-drawing/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/home/phuong/shared/code/git/github/online-drawing/client/src/components/Canvas.js\";\nimport React, { useRef, useState, useContext, useEffect } from 'react';\nimport { Context } from '../store/store';\nimport { types } from '../store/types';\n\nfunction Canvas() {\n  /**\n   * NOTE: I can remove current_path state, and store data as last element in paths state.\n   * if doing so, I need to have update paths state for every cursor move. Therefore, \n   * the state is coppied many times ( the state contains arrays of hundreds of objects)\n   * \n   */\n  const canvasRef = useRef(null);\n\n  const _useContext = useContext(Context),\n        state = _useContext.state,\n        dispatch = _useContext.dispatch;\n\n  const _useState = useState(false),\n        _useState2 = _slicedToArray(_useState, 2),\n        is_drawing = _useState2[0],\n        setIsDrawing = _useState2[1]; // const [paths, setPaths] = useState([])\n  // a path is a collection of dots when a mouse pressed down, moved, released. \n\n\n  const _useState3 = useState([]),\n        _useState4 = _slicedToArray(_useState3, 2),\n        current_path = _useState4[0],\n        setCurrentPath = _useState4[1];\n\n  useEffect(() => {\n    const canvas = canvasRef.current; //https://stackoverflow.com/questions/10214873/make-canvas-as-wide-and-as-high-as-parent\n\n    canvas.width = canvas.offsetWidth;\n    canvas.height = canvas.offsetHeight;\n  }, []);\n  useEffect(() => {\n    if (state.clear) {\n      const canvas = canvasRef.current;\n      const ctx = canvas.getContext('2d');\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      dispatch({\n        type: types.SET_CLEAR,\n        payload: false\n      });\n    }\n  }, [state.clear]); // draw a line from start to end\n\n  const drawLine = (ctx, start, end) => {\n    // ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n    ctx.strokeStyle = state.color;\n    ctx.lineWidth = state.width;\n    ctx.beginPath();\n    ctx.moveTo(start.x, start.y);\n    ctx.lineTo(end.x, end.y);\n    ctx.stroke();\n  }; // triggered when the mouse pressed down\n  // get current mouse location, and signal drawing has begun\n\n\n  const startDrawing = e => {\n    setIsDrawing(true);\n    const canvas = canvasRef.current;\n    let pos = getMousePos(canvas, e);\n    setCurrentPath(prev => [...prev, pos]);\n  }; // draw lines to current mouse location\n\n\n  const draw = e => {\n    if (is_drawing) {\n      const canvas = canvasRef.current;\n      const ctx = canvas.getContext('2d');\n\n      if (current_path.length >= 2) {\n        drawLine(ctx, current_path[current_path.length - 2], current_path[current_path.length - 1]);\n      }\n\n      let pos = getMousePos(canvas, e);\n      setCurrentPath(prev => [...prev, pos]);\n    }\n  }; // signal drawing has stoped\n\n\n  const stopDrawing = () => {\n    setIsDrawing(false); // setPaths(prev => [...prev, current_path])\n\n    setCurrentPath([]);\n  }; // https://stackoverflow.com/questions/17130395/real-mouse-position-in-canvas\n\n\n  function getMousePos(canvas, evt) {\n    var rect = canvas.getBoundingClientRect();\n    return {\n      x: evt.clientX - rect.left,\n      y: evt.clientY - rect.top\n    };\n  }\n\n  return React.createElement(\"div\", {\n    style: {\n      width: '100%',\n      height: '100%',\n      cursor: 'pointer'\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 85\n    },\n    __self: this\n  }, React.createElement(\"canvas\", {\n    ref: canvasRef,\n    style: {\n      width: '100%',\n      height: '100%'\n    },\n    onMouseDown: startDrawing,\n    onMouseMove: draw,\n    onMouseUp: stopDrawing,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 89\n    },\n    __self: this\n  }));\n}\n\nexport default React.memo(Canvas);","map":{"version":3,"sources":["/home/phuong/shared/code/git/github/online-drawing/client/src/components/Canvas.js"],"names":["React","useRef","useState","useContext","useEffect","Context","types","Canvas","canvasRef","state","dispatch","is_drawing","setIsDrawing","current_path","setCurrentPath","canvas","current","width","offsetWidth","height","offsetHeight","clear","ctx","getContext","clearRect","type","SET_CLEAR","payload","drawLine","start","end","strokeStyle","color","lineWidth","beginPath","moveTo","x","y","lineTo","stroke","startDrawing","e","pos","getMousePos","prev","draw","length","stopDrawing","evt","rect","getBoundingClientRect","clientX","left","clientY","top","cursor","memo"],"mappings":"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","sourcesContent":["import React, { useRef, useState, useContext, useEffect } from 'react'\n\nimport { Context } from '../store/store'\nimport { types } from '../store/types'\n\nfunction Canvas() {\n  /**\n   * NOTE: I can remove current_path state, and store data as last element in paths state.\n   * if doing so, I need to have update paths state for every cursor move. Therefore, \n   * the state is coppied many times ( the state contains arrays of hundreds of objects)\n   * \n   */\n  const canvasRef = useRef(null)\n  const { state, dispatch } = useContext(Context)\n  const [is_drawing, setIsDrawing] = useState(false)\n  // const [paths, setPaths] = useState([])\n  // a path is a collection of dots when a mouse pressed down, moved, released. \n  const [current_path, setCurrentPath] = useState([])\n\n  useEffect(() => {\n    const canvas = canvasRef.current\n    //https://stackoverflow.com/questions/10214873/make-canvas-as-wide-and-as-high-as-parent\n    canvas.width = canvas.offsetWidth\n    canvas.height = canvas.offsetHeight\n  }, [])\n\n  useEffect(() => {\n    if (state.clear) {\n      const canvas = canvasRef.current\n      const ctx = canvas.getContext('2d')\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n      dispatch({ type: types.SET_CLEAR, payload: false })\n    }\n  }, [state.clear])\n\n  // draw a line from start to end\n  const drawLine = (ctx, start, end) => {\n    // ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n    ctx.strokeStyle = state.color\n    ctx.lineWidth = state.width\n    ctx.beginPath()\n    ctx.moveTo(start.x, start.y)\n    ctx.lineTo(end.x, end.y)\n    ctx.stroke()\n  }\n\n  // triggered when the mouse pressed down\n  // get current mouse location, and signal drawing has begun\n  const startDrawing = (e) => {\n    setIsDrawing(true)\n    const canvas = canvasRef.current\n    let pos = getMousePos(canvas, e)\n    setCurrentPath(prev => [...prev, pos])\n  }\n\n  // draw lines to current mouse location\n  const draw = (e) => {\n    if (is_drawing) {\n      const canvas = canvasRef.current\n      const ctx = canvas.getContext('2d')\n      if (current_path.length >= 2) {\n        drawLine(ctx, current_path[current_path.length - 2], current_path[current_path.length - 1])\n      }\n      let pos = getMousePos(canvas, e)\n      setCurrentPath(prev => [...prev, pos])\n    }\n  }\n\n  // signal drawing has stoped\n  const stopDrawing = () => {\n    setIsDrawing(false)\n    // setPaths(prev => [...prev, current_path])\n    setCurrentPath([])\n  }\n\n  // https://stackoverflow.com/questions/17130395/real-mouse-position-in-canvas\n  function getMousePos(canvas, evt) {\n    var rect = canvas.getBoundingClientRect();\n    return {\n      x: evt.clientX - rect.left,\n      y: evt.clientY - rect.top\n    }\n  }\n  return (\n    <div style={{\n      width: '100%',\n      height: '100%',\n      cursor: 'pointer'}}>\n      <canvas\n        ref={canvasRef}\n        style={{ width: '100%', height: '100%' }}\n        onMouseDown={startDrawing}\n        onMouseMove={draw}\n        onMouseUp={stopDrawing}\n      />\n    </div>\n  )\n}\n\nexport default React.memo(Canvas)"]},"metadata":{},"sourceType":"module"}